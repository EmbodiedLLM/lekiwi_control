<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>虚拟摇杆测试</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      background-color: #f0f0f0;
    }

    #joystick-container {
      width: 200px; /* 底座容器宽度 */
      height: 200px; /* 底座容器高度 */
      position: relative; /* 用于内部绝对定位 */
      margin: 30px auto; /* 页面居中显示 */
      touch-action: none; /* 防止触摸操作时页面滚动缩放 */
      border: 2px solid #bbb; /* 给容器一个边框，方便看边界 */
      border-radius: 50%; /* 容器也做成圆形，匹配底座 */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #joystick-base {
      width: 100%; /* 宽度占满容器 */
      height: 100%; /* 高度占满容器 */
      background-color: #e0e0e0; /* 底座颜色 */
      border-radius: 50%; /* 圆形 */
      position: absolute; /* 相对于 container 定位 */
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }

    #joystick-handle {
      width: 80px; /* 摇杆头宽度 */
      height: 80px; /* 摇杆头高度 */
      background-color: #757575; /* 摇杆头颜色 */
      border-radius: 50%; /* 圆形 */
      position: absolute; /* 相对于 container 定位 */
      /* 初始居中通过JS设置，或保留CSS方式 */
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      cursor: grab;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
      z-index: 10; /* 确保摇杆头在底座之上 */
    }

    #joystick-handle:active {
      cursor: grabbing;
      background-color: #5e5e5e; /* 按下时颜色稍深 */
    }

    #data-display { /* 用于显示摇杆输出数据，方便调试 */
      text-align: center;
      margin-top: 20px;
      font-size: 18px;
      font-family: monospace;
      padding: 10px;
      background-color: #fff;
      border-radius: 5px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
    }
  </style>
</head>
<body>

  <h1>虚拟摇杆测试页面</h1>

  <div id="joystick-container">
    <div id="joystick-base"></div>
    <div id="joystick-handle"></div>
  </div>

  <div id="data-display">X: 0, Y: 0</div>

  <script>
    const joystickContainer = document.getElementById('joystick-container');
    const joystickBase = document.getElementById('joystick-base'); // 虽然有base div，但中心点计算基于container
    const joystickHandle = document.getElementById('joystick-handle');
    const dataDisplay = document.getElementById('data-display');

    const containerRect = joystickContainer.getBoundingClientRect();
    const handleRadius = joystickHandle.offsetWidth / 2;
    // const baseRadius = joystickBase.offsetWidth / 2; // 或者 joystickContainer.offsetWidth / 2
    const baseRadius = joystickContainer.offsetWidth / 2; // 摇杆活动范围的基准半径
    const maxMoveRadius = baseRadius - handleRadius; // 摇杆头中心能移动的最大半径

    let isDragging = false;
    let centerX, centerY; // container 的中心点

    // 计算底座中心点，考虑页面滚动和缩放
    function calculateCenter() {
      const rect = joystickContainer.getBoundingClientRect(); // 使用 container 的 rect
      centerX = rect.left + rect.width / 2;
      centerY = rect.top + rect.height / 2;
      // console.log("Center X:", centerX, "Center Y:", centerY);
    }
    
    // 初始计算中心点，并确保DOM加载完毕获取正确尺寸
    window.addEventListener('load', () => {
        calculateCenter();
        // 确保摇杆头在JS加载后正确居中（如果CSS的 transform 失效或被覆盖）
        joystickHandle.style.left = (baseRadius - handleRadius) + 'px';
        joystickHandle.style.top = (baseRadius - handleRadius) + 'px';
    });
    window.addEventListener('resize', calculateCenter); // 窗口大小变化时重新计算

    // 统一处理鼠标和触摸事件的起始
    function dragStart(event) {
      // 确保中心点是最新的，特别是对于可能动态加载的页面
      calculateCenter(); 
      
      isDragging = true;
      joystickHandle.style.transition = 'none'; // 拖动时不应用过渡效果
      joystickHandle.style.cursor = 'grabbing';

      if (event.type === 'touchstart') {
        document.addEventListener('touchmove', dragging, { passive: false });
        document.addEventListener('touchend', dragEnd);
        document.addEventListener('touchcancel', dragEnd); // 处理意外取消
      } else { // mousedown
        document.addEventListener('mousemove', dragging);
        document.addEventListener('mouseup', dragEnd);
      }
      // event.preventDefault(); // 可以在dragging中按需调用
    }

    // 拖动过程
    function dragging(event) {
      if (!isDragging) return;
      event.preventDefault(); // 阻止页面滚动等默认行为，尤其对触摸

      let clientX, clientY;
      if (event.type === 'touchmove' || event.type === 'touchstart') { // touchstart也能触发首次定位
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
      } else { // mousemove
        clientX = event.clientX;
        clientY = event.clientY;
      }

      let deltaX = clientX - centerX;
      let deltaY = clientY - centerY;

      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const angle = Math.atan2(deltaY, deltaX); // 计算角度

      let stickX, stickY;

      if (distance > maxMoveRadius) {
        // 限制在圆圈边缘
        stickX = maxMoveRadius * Math.cos(angle);
        stickY = maxMoveRadius * Math.sin(angle);
      } else {
        stickX = deltaX;
        stickY = deltaY;
      }

      // 更新摇杆头位置 (相对于底座中心，调整使其基于左上角定位)
      // 摇杆的 left/top 是相对于其父容器(joystick-container)的，
      // 而摇杆头中心 (stickX, stickY) 是相对于 joystick-container 中心的。
      // 所以，摇杆头的 left = baseRadius + stickX - handleRadius
      joystickHandle.style.left = (baseRadius + stickX - handleRadius) + 'px';
      joystickHandle.style.top = (baseRadius + stickY - handleRadius) + 'px';


      // 输出摇杆数据 (Y轴通常向上为正，但屏幕坐标向下为正，所以取反)
      // 输出范围可以根据 maxMoveRadius 进行归一化，例如 -1 到 +1
      let outputX = stickX / maxMoveRadius;
      let outputY = -stickY / maxMoveRadius; // Y轴反向，使向上为正

      // 避免极端情况下出现略大于1或小于-1的值 (由于浮点数精度)
      outputX = Math.max(-1, Math.min(1, outputX));
      outputY = Math.max(-1, Math.min(1, outputY));

      outputX = parseFloat(outputX.toFixed(2)); // 保留两位小数
      outputY = parseFloat(outputY.toFixed(2));

      dataDisplay.textContent = `X: ${outputX}, Y: ${outputY}`;
      sendJoystickData(outputX, outputY);
    }

    // 拖动结束
    function dragEnd(event) {
      if (!isDragging) return;
      isDragging = false;
      joystickHandle.style.transition = 'left 0.2s ease-out, top 0.2s ease-out'; // 回中过渡效果
      // 回到中心位置 (相对于父容器 baseRadius - handleRadius 是中心点)
      joystickHandle.style.left = (baseRadius - handleRadius) + 'px';
      joystickHandle.style.top = (baseRadius - handleRadius) + 'px';
      joystickHandle.style.cursor = 'grab';


      if (event.type === 'touchend' || event.type === 'touchcancel') {
        document.removeEventListener('touchmove', dragging);
        document.removeEventListener('touchend', dragEnd);
        document.removeEventListener('touchcancel', dragEnd);
      } else { // mouseup
        document.removeEventListener('mousemove', dragging);
        document.removeEventListener('mouseup', dragEnd);
      }

      dataDisplay.textContent = 'X: 0, Y: 0';
      sendJoystickData(0, 0); // 发送停止信号
    }

    joystickHandle.addEventListener('mousedown', dragStart);
    joystickHandle.addEventListener('touchstart', dragStart, { passive: false }); // passive:false 允许preventDefault

    // 发送数据到ESP32 (示例)
    let lastSentTime = 0;
    const sendInterval = 100; // 每100毫秒最多发送一次

    function sendJoystickData(x, y) {
      const now = Date.now();